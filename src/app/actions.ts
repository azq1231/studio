'use server';

import { parseCreditCard, parseDepositAccount, type CreditData, type DepositData, type CashData, ParsedCreditDataWithCategory, parseExcelData } from '@/lib/parser';

export type ReplacementRule = {
    find: string;
    replace: string;
    deleteRow?: boolean;
    notes?: string;
};

export type CategoryRule = {
    keyword: string;
    category: string;
};

function applyReplacementRules(description: string, rules: ReplacementRule[]): { processedText: string, shouldDelete: boolean } {
    let processedText = description;
    let shouldDelete = false;

    for (const rule of rules) {
        if (rule.find && description.includes(rule.find)) {
            if (rule.deleteRow) {
                shouldDelete = true;
                break;
            }
            processedText = processedText.replace(new RegExp(rule.find, 'g'), rule.replace);
        }
    }
    return { processedText, shouldDelete };
}


function applyCategoryRules(description: string, rules: CategoryRule[]): string {
    for (const rule of rules) {
        if (rule.keyword && description.includes(rule.keyword)) {
            return rule.category;
        }
    }
    // If no rules match, return a default or empty category
    return '未分類';
}

async function processSingleCreditEntry(entry: ParsedCreditDataWithCategory, replacementRules: ReplacementRule[], categoryRules: CategoryRule[]): Promise<CreditData | null> {
    const { processedText: processedDescription, shouldDelete } = applyReplacementRules(entry.description, replacementRules);
    
    if (shouldDelete || !processedDescription.trim()) {
        return null;
    }
    
    // If a category was parsed directly from the paste, use it. Otherwise, apply rules.
    const category = entry.category || applyCategoryRules(processedDescription, categoryRules);

    return {
        id: entry.id, // Use the stable ID generated by the parser
        transactionDate: entry.transactionDate,
        category: category,
        description: processedDescription,
        amount: entry.amount,
        bankCode: entry.bankCode // Keep bank code if parser found it
    };
}


export async function processBankStatement(
    text: string, 
    replacementRules: ReplacementRule[],
    categoryRules: CategoryRule[],
    isExcelUpload: boolean = false,
    excelData?: any[][]
): Promise<{
    success: boolean;
    creditData: CreditData[];
    depositData: DepositData[];
    cashData: CashData[];
    detectedCategories: string[];
    error?: string;
}> {
    if (!text && !isExcelUpload) {
        return { success: false, creditData: [], depositData: [], cashData: [], detectedCategories: [], error: "No text provided." };
    }

    try {
        const detectedCategories = new Set<string>();
        let allCreditData: CreditData[] = [];
        let allDepositData: DepositData[] = [];
        let allCashData: CashData[] = [];

        if (isExcelUpload && excelData) {
            const parsedDataFromExcel = await parseExcelData(excelData);
            // Excel data is assumed to be clean and categorized, so we pass it through.
            allCreditData = parsedDataFromExcel.creditData;
            allDepositData = parsedDataFromExcel.depositData;
            allCashData = parsedDataFromExcel.cashData;
            parsedDataFromExcel.detectedCategories.forEach(c => detectedCategories.add(c));
        } else {
             // Attempt to parse as credit card data. This now returns raw data with stable IDs.
            const rawCreditParsed = await parseCreditCard(text);
            
            // Attempt to parse as deposit account data. This also now returns raw data with stable IDs.
            const rawDepositParsed = await parseDepositAccount(text);

            // Process credit card entries by applying rules
            rawCreditParsed.forEach(c => { if(c.category) detectedCategories.add(c.category) });
            const processedCreditPromises = rawCreditParsed.map(entry => processSingleCreditEntry(entry, replacementRules, categoryRules));
            allCreditData = (await Promise.all(processedCreditPromises)).filter((e): e is CreditData => e !== null);

            // Process deposit account entries by applying rules
            const processedDepositPromises = rawDepositParsed.map(async (entry) => {
                const { processedText, shouldDelete } = applyReplacementRules(entry.description, replacementRules);
                if (shouldDelete) return null;

                const category = applyCategoryRules(processedText, categoryRules);
                detectedCategories.add(category);
                
                return {
                    ...entry,
                    description: processedText,
                    category: category
                };
            });
            allDepositData = (await Promise.all(processedDepositPromises)).filter((e): e is DepositData => e !== null);
        }
        
        return { 
            success: true, 
            creditData: allCreditData, 
            depositData: allDepositData, 
            cashData: allCashData,
            detectedCategories: Array.from(detectedCategories) 
        };

    } catch (e) {
        console.error("Error processing bank statement:", e);
        const error = e instanceof Error ? e.message : 'An unknown error occurred during parsing.';
        return { success: false, creditData: [], depositData: [], cashData: [], detectedCategories: [], error };
    }
}

/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model where all data is
 * siloed within a user-specific document tree. The primary goal is to guarantee the privacy
 * and security of sensitive financial transaction data, ensuring that a user can only ever
 * access their own information.
 *
 * Data Structure: All data is organized hierarchically under the `/users/{userId}` path.
 * Each user's document contains two distinct subcollections for their financial data:
 * `creditCardTransactions` and `depositAccountTransactions`. This separation simplifies
 * rules and ensures data integrity.
 *   - /users/{userId}
 *     - /creditCardTransactions/{transactionId}
 *     - /depositAccountTransactions/{transactionId}
 *
 * Key Security Decisions:
 * - User data is strictly isolated. Access is granted only when the authenticated user's
 *   UID matches the `{userId}` in the document path.
 * - Listing all users is explicitly disallowed to prevent user enumeration.
 * - The root user document (`/users/{userId}`) is read-only for the owner and cannot be
 *   modified by clients, assuming it is managed server-side.
 * - There is no public or shared data; all collections are private.
 *
 * Denormalization for Authorization: This ruleset leverages a path-based security model,
 * which is a form of structural denormalization. By placing all of a user's data under a
 * path containing their UID (`/users/{userId}`), authorization checks become extremely
 * fast and simple. We do not need to read other documents (using `get()`) to verify
 * ownership, leading to better performance and lower costs.
 *
 * Structural Segregation: Credit card transactions and deposit account transactions are
 * stored in separate, dedicated subcollections. This design choice creates homogeneous
 * collections where all documents share the same security context, resulting in cleaner,
 * more maintainable, and more secure rules than if they were mixed in a single collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to improve readability and reuse of logic.

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the currently signed-in user's UID matches the
     * provided userId from the document path. This is the core function
     * for enforcing user ownership.
     * @param userId The UID of the user to check against.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the user is the owner AND the document already exists.
     * Used for safe update and delete operations.
     * @param userId The UID of the user to check against.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description   Provides a read-only root document for user-specific data. Disallows
     *                all client-side writes to prevent modification of core user data and
     *                forbids listing to prevent user enumeration.
     * @path          /users/{userId}
     * @allow         A user (auth.uid: 'user_abc') can read their own user document at `/users/user_abc`. (get)
     * @deny          A user (auth.uid: 'user_xyz') CANNOT read another user's document at `/users/user_abc`. (get)
     * @deny          No user can list all documents in the `/users` collection. (list)
     * @deny          No user can create, update, or delete their own user document. (create, update, delete)
     * @principle     Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description   Secures a user's private credit card transactions. Only the user who
     *                owns this data can perform any read or write operations.
     * @path          /users/{userId}/creditCardTransactions/{transactionId}
     * @allow         A user (auth.uid: 'user_abc') can create a new transaction at `/users/user_abc/creditCardTransactions/trans_123`. (create)
     * @allow         The same user can read, update, or delete that transaction. (get, update, delete)
     * @deny          Another user (auth.uid: 'user_xyz') CANNOT read or write to `/users/user_abc/creditCardTransactions/trans_123`.
     * @principle     Enforces strict data ownership for all operations within a user's private subcollection.
     */
    match /users/{userId}/creditCardTransactions/{transactionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description   Secures a user's private deposit account transactions. Only the user
     *                who owns this data can perform any read or write operations.
     * @path          /users/{userId}/depositAccountTransactions/{transactionId}
     * @allow         A user (auth.uid: 'user_abc') can create a new transaction at `/users/user_abc/depositAccountTransactions/trans_456`. (create)
     * @allow         The same user can read, update, or delete that transaction. (get, update, delete)
     * @deny          Another user (auth.uid: 'user_xyz') CANNOT read or write to `/users/user_abc/depositAccountTransactions/trans_456`.
     * @principle     Enforces strict data ownership for all operations within a user's private subcollection.
     */
    match /users/{userId}/depositAccountTransactions/{transactionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }
  }
}